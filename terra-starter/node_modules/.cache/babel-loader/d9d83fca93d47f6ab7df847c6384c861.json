{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SignatureV2 = void 0;\n\nvar PublicKey_1 = require(\"./PublicKey\");\n\nvar Tx_1 = require(\"./Tx\");\n\nvar CompactBitArray_1 = require(\"./CompactBitArray\");\n\nvar signing_1 = require(\"@terra-money/terra.proto/cosmos/tx/signing/v1beta1/signing\");\n\nvar multisig_1 = require(\"@terra-money/terra.proto/cosmos/crypto/multisig/v1beta1/multisig\");\n\nvar SignatureV2 =\n/** @class */\nfunction () {\n  function SignatureV2(public_key, data, sequence) {\n    this.public_key = public_key;\n    this.data = data;\n    this.sequence = sequence;\n  }\n\n  SignatureV2.fromData = function (data) {\n    return new SignatureV2(PublicKey_1.PublicKey.fromData(data.public_key), SignatureV2.Descriptor.fromData(data.data), Number.parseInt(data.sequence));\n  };\n\n  SignatureV2.prototype.toData = function () {\n    return {\n      public_key: this.public_key.toData(),\n      data: this.data.toData(),\n      sequence: this.sequence.toFixed()\n    };\n  };\n\n  SignatureV2.fromAmino = function (data) {\n    return new SignatureV2(PublicKey_1.PublicKey.fromAmino(data.pub_key), new SignatureV2.Descriptor(new SignatureV2.Descriptor.Single(SignatureV2.SignMode.SIGN_MODE_LEGACY_AMINO_JSON, data.signature)), 0);\n  };\n\n  return SignatureV2;\n}();\n\nexports.SignatureV2 = SignatureV2;\n\n(function (SignatureV2) {\n  SignatureV2.SignMode = signing_1.SignMode;\n\n  var Descriptor =\n  /** @class */\n  function () {\n    function Descriptor(data) {\n      data instanceof Descriptor.Single ? this.single = data : this.multi = data;\n    }\n\n    Descriptor.fromData = function (data) {\n      if (data.single) {\n        return new Descriptor(Descriptor.Single.fromData(data.single));\n      }\n\n      if (data.multi) {\n        return new Descriptor(Descriptor.Multi.fromData(data.multi));\n      }\n\n      throw new Error('must be one of single or multi');\n    };\n\n    Descriptor.prototype.toData = function () {\n      if (this.single) {\n        return {\n          single: this.single.toData()\n        };\n      }\n\n      if (this.multi) {\n        return {\n          multi: this.multi.toData()\n        };\n      }\n\n      throw new Error('must be one of single or multi');\n    };\n\n    Descriptor.prototype.toModeInfoAndSignature = function () {\n      if (this.single) {\n        var sigData = this.single;\n        return [new Tx_1.ModeInfo(new Tx_1.ModeInfo.Single(sigData.mode)), Buffer.from(sigData.signature, 'base64')];\n      }\n\n      if (this.multi) {\n        var sigData = this.multi;\n        var modeInfos = [];\n        var signatures = [];\n\n        for (var _i = 0, _a = sigData.signatures; _i < _a.length; _i++) {\n          var signature = _a[_i];\n\n          var _b = signature.toModeInfoAndSignature(),\n              modeInfo = _b[0],\n              sigBytes = _b[1];\n\n          modeInfos.push(modeInfo);\n          signatures.push(sigBytes);\n        }\n\n        var multisigBytes = multisig_1.MultiSignature.encode(multisig_1.MultiSignature.fromPartial({\n          signatures: signatures\n        })).finish();\n        return [new Tx_1.ModeInfo(new Tx_1.ModeInfo.Multi(sigData.bitarray, modeInfos)), multisigBytes];\n      }\n\n      throw new Error('invalid signature descriptor');\n    };\n\n    return Descriptor;\n  }();\n\n  SignatureV2.Descriptor = Descriptor;\n\n  (function (Descriptor) {\n    var Single =\n    /** @class */\n    function () {\n      function Single(mode, signature) {\n        this.mode = mode;\n        this.signature = signature;\n      }\n\n      Single.fromData = function (data) {\n        return new Single((0, signing_1.signModeFromJSON)(data.mode), data.signature);\n      };\n\n      Single.prototype.toData = function () {\n        var _a = this,\n            mode = _a.mode,\n            signature = _a.signature;\n\n        return {\n          mode: (0, signing_1.signModeToJSON)(mode),\n          signature: signature\n        };\n      };\n\n      return Single;\n    }();\n\n    Descriptor.Single = Single;\n\n    var Multi =\n    /** @class */\n    function () {\n      function Multi(bitarray, signatures) {\n        this.bitarray = bitarray;\n        this.signatures = signatures;\n      }\n\n      Multi.fromData = function (data) {\n        return new Multi(CompactBitArray_1.CompactBitArray.fromData(data.bitarray), data.signatures.map(function (v) {\n          return Descriptor.fromData(v);\n        }));\n      };\n\n      Multi.prototype.toData = function () {\n        return {\n          bitarray: this.bitarray.toData(),\n          signatures: this.signatures.map(function (sig) {\n            return sig.toData();\n          })\n        };\n      };\n\n      return Multi;\n    }();\n\n    Descriptor.Multi = Multi;\n  })(Descriptor = SignatureV2.Descriptor || (SignatureV2.Descriptor = {}));\n})(SignatureV2 = exports.SignatureV2 || (exports.SignatureV2 = {}));\n\nexports.SignatureV2 = SignatureV2;","map":{"version":3,"sources":["../../src/core/SignatureV2.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SignatureV2 = void 0;\nvar PublicKey_1 = require(\"./PublicKey\");\nvar Tx_1 = require(\"./Tx\");\nvar CompactBitArray_1 = require(\"./CompactBitArray\");\nvar signing_1 = require(\"@terra-money/terra.proto/cosmos/tx/signing/v1beta1/signing\");\nvar multisig_1 = require(\"@terra-money/terra.proto/cosmos/crypto/multisig/v1beta1/multisig\");\nvar SignatureV2 = /** @class */ (function () {\n    function SignatureV2(public_key, data, sequence) {\n        this.public_key = public_key;\n        this.data = data;\n        this.sequence = sequence;\n    }\n    SignatureV2.fromData = function (data) {\n        return new SignatureV2(PublicKey_1.PublicKey.fromData(data.public_key), SignatureV2.Descriptor.fromData(data.data), Number.parseInt(data.sequence));\n    };\n    SignatureV2.prototype.toData = function () {\n        return {\n            public_key: this.public_key.toData(),\n            data: this.data.toData(),\n            sequence: this.sequence.toFixed(),\n        };\n    };\n    SignatureV2.fromAmino = function (data) {\n        return new SignatureV2(PublicKey_1.PublicKey.fromAmino(data.pub_key), new SignatureV2.Descriptor(new SignatureV2.Descriptor.Single(SignatureV2.SignMode.SIGN_MODE_LEGACY_AMINO_JSON, data.signature)), 0);\n    };\n    return SignatureV2;\n}());\nexports.SignatureV2 = SignatureV2;\n(function (SignatureV2) {\n    SignatureV2.SignMode = signing_1.SignMode;\n    var Descriptor = /** @class */ (function () {\n        function Descriptor(data) {\n            data instanceof Descriptor.Single\n                ? (this.single = data)\n                : (this.multi = data);\n        }\n        Descriptor.fromData = function (data) {\n            if (data.single) {\n                return new Descriptor(Descriptor.Single.fromData(data.single));\n            }\n            if (data.multi) {\n                return new Descriptor(Descriptor.Multi.fromData(data.multi));\n            }\n            throw new Error('must be one of single or multi');\n        };\n        Descriptor.prototype.toData = function () {\n            if (this.single) {\n                return {\n                    single: this.single.toData(),\n                };\n            }\n            if (this.multi) {\n                return {\n                    multi: this.multi.toData(),\n                };\n            }\n            throw new Error('must be one of single or multi');\n        };\n        Descriptor.prototype.toModeInfoAndSignature = function () {\n            if (this.single) {\n                var sigData = this.single;\n                return [\n                    new Tx_1.ModeInfo(new Tx_1.ModeInfo.Single(sigData.mode)),\n                    Buffer.from(sigData.signature, 'base64'),\n                ];\n            }\n            if (this.multi) {\n                var sigData = this.multi;\n                var modeInfos = [];\n                var signatures = [];\n                for (var _i = 0, _a = sigData.signatures; _i < _a.length; _i++) {\n                    var signature = _a[_i];\n                    var _b = signature.toModeInfoAndSignature(), modeInfo = _b[0], sigBytes = _b[1];\n                    modeInfos.push(modeInfo);\n                    signatures.push(sigBytes);\n                }\n                var multisigBytes = multisig_1.MultiSignature.encode(multisig_1.MultiSignature.fromPartial({\n                    signatures: signatures,\n                })).finish();\n                return [\n                    new Tx_1.ModeInfo(new Tx_1.ModeInfo.Multi(sigData.bitarray, modeInfos)),\n                    multisigBytes,\n                ];\n            }\n            throw new Error('invalid signature descriptor');\n        };\n        return Descriptor;\n    }());\n    SignatureV2.Descriptor = Descriptor;\n    (function (Descriptor) {\n        var Single = /** @class */ (function () {\n            function Single(mode, signature) {\n                this.mode = mode;\n                this.signature = signature;\n            }\n            Single.fromData = function (data) {\n                return new Single((0, signing_1.signModeFromJSON)(data.mode), data.signature);\n            };\n            Single.prototype.toData = function () {\n                var _a = this, mode = _a.mode, signature = _a.signature;\n                return {\n                    mode: (0, signing_1.signModeToJSON)(mode),\n                    signature: signature,\n                };\n            };\n            return Single;\n        }());\n        Descriptor.Single = Single;\n        var Multi = /** @class */ (function () {\n            function Multi(bitarray, signatures) {\n                this.bitarray = bitarray;\n                this.signatures = signatures;\n            }\n            Multi.fromData = function (data) {\n                return new Multi(CompactBitArray_1.CompactBitArray.fromData(data.bitarray), data.signatures.map(function (v) { return Descriptor.fromData(v); }));\n            };\n            Multi.prototype.toData = function () {\n                return {\n                    bitarray: this.bitarray.toData(),\n                    signatures: this.signatures.map(function (sig) { return sig.toData(); }),\n                };\n            };\n            return Multi;\n        }());\n        Descriptor.Multi = Multi;\n    })(Descriptor = SignatureV2.Descriptor || (SignatureV2.Descriptor = {}));\n})(SignatureV2 = exports.SignatureV2 || (exports.SignatureV2 = {}));\nexports.SignatureV2 = SignatureV2;\n//# sourceMappingURL=SignatureV2.js.map"]},"metadata":{},"sourceType":"script"}