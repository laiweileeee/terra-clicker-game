{"ast":null,"code":"import { AccAddress, PublicKey, Tx } from '@terra-money/terra.js';\nimport { ConnectType, WalletStatus } from '@terra-money/wallet-types';\nimport { WebExtensionTxStatus } from '@terra-money/web-extension-interface';\nimport deepEqual from 'fast-deep-equal';\nimport { BehaviorSubject, combineLatest, firstValueFrom } from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\nimport { CHROME_EXTENSION_INSTALL_URL, DEFAULT_CHROME_EXTENSION_COMPATIBLE_BROWSER_CHECK } from './env';\nimport { mapExtensionSignBytesError, mapExtensionTxError } from './exception/mapExtensionTxError';\nimport { mapWalletConnectError } from './exception/mapWalletConnectError';\nimport { selectConnection } from './modules/connect-modal';\nimport { ExtensionRouter, ExtensionRouterStatus } from './modules/extension-router';\nimport { getTerraExtensions } from './modules/extension-router/multiChannel';\nimport { connect as reConnect, connectIfSessionExists as reConnectIfSessionExists, readonlyWalletModal } from './modules/readonly-wallet';\nimport { connect as wcConnect, connectIfSessionExists as wcConnectIfSessionExists, WalletConnectSessionStatus } from './modules/walletconnect';\nimport { getExtensions } from './operators/getExtensions';\nimport { toConnectedWallet } from './operators/toConnectedWallet';\nimport { toLcdClient } from './operators/toLcdClient';\nimport { isDesktopChrome } from './utils/browser-check';\nimport { checkExtensionReady } from './utils/checkExtensionReady';\nimport { sortConnections } from './utils/sortConnections';\nconst CONNECTIONS = {\n  [ConnectType.READONLY]: {\n    type: ConnectType.READONLY,\n    name: 'View an address',\n    icon: 'https://assets.terra.money/icon/wallet-provider/readonly.svg'\n  },\n  [ConnectType.WALLETCONNECT]: {\n    type: ConnectType.WALLETCONNECT,\n    name: 'Wallet Connect',\n    icon: 'https://assets.terra.money/icon/wallet-provider/walletconnect.svg'\n  }\n};\nconst DEFAULT_WAITING_CHROME_EXTENSION_INSTALL_CHECK = 1000 * 3;\nconst WALLETCONNECT_SUPPORT_FEATURES = new Set(['post']);\nconst EMPTY_SUPPORT_FEATURES = new Set(); //noinspection ES6MissingAwait\n\nexport class WalletController {\n  constructor(options) {\n    var _this = this;\n\n    var _a;\n\n    this.options = options;\n    this.extension = null;\n    this.walletConnect = null;\n    this.readonlyWallet = null;\n    this.disableReadonlyWallet = null;\n    this.disableExtension = null;\n    this.disableWalletConnect = null;\n    /**\n     * Some mobile wallet emulates the behavior of chrome extension.\n     * It confirms that the current connection environment is such a wallet.\n     * (If you are running connect() by checking availableConnectType, you do not need to use this API.)\n     *\n     * @see Wallet#isChromeExtensionCompatibleBrowser\n     */\n\n    this.isChromeExtensionCompatibleBrowser = () => {\n      var _a;\n\n      return ((_a = this.options.dangerously__chromeExtensionCompatibleBrowserCheck) !== null && _a !== void 0 ? _a : DEFAULT_CHROME_EXTENSION_COMPATIBLE_BROWSER_CHECK)(navigator.userAgent);\n    };\n    /**\n     * available connect types on the browser\n     *\n     * @see Wallet#availableConnectTypes\n     */\n\n\n    this.availableConnectTypes = () => {\n      return this._availableConnectTypes.asObservable();\n    };\n    /**\n     * available connections includes identifier, name, icon\n     *\n     * @see Wallet#availableConnections\n     */\n\n\n    this.availableConnections = () => {\n      return this._availableConnectTypes.pipe(map(connectTypes => {\n        const connections = [];\n\n        for (const connectType of connectTypes) {\n          if (connectType === ConnectType.EXTENSION) {\n            const terraExtensions = getTerraExtensions();\n\n            for (const terraExtension of terraExtensions) {\n              connections.push(memoConnection(ConnectType.EXTENSION, terraExtension.name, terraExtension.icon, terraExtension.identifier));\n            }\n          } else {\n            connections.push(CONNECTIONS[connectType]);\n          }\n        }\n\n        return sortConnections(connections);\n      }));\n    };\n    /**\n     * available install types on the browser\n     *\n     * in this time, this only contains [ConnectType.EXTENSION]\n     *\n     * @see Wallet#availableInstallTypes\n     */\n\n\n    this.availableInstallTypes = () => {\n      return this._availableInstallTypes.asObservable();\n    };\n    /**\n     * available installations includes identifier, name, icon, url\n     *\n     * @see Wallet#availableInstallations\n     */\n\n\n    this.availableInstallations = () => {\n      return combineLatest([this.availableConnections(), getExtensions()]).pipe(map(_ref => {\n        let [connections, extensions] = _ref;\n        const installedIdentifiers = new Set(connections.filter(_ref2 => {\n          let {\n            type,\n            identifier\n          } = _ref2;\n          return type === ConnectType.EXTENSION && !!identifier;\n        }).map(_ref3 => {\n          let {\n            identifier\n          } = _ref3;\n          return identifier;\n        }));\n        return extensions.filter(_ref4 => {\n          let {\n            identifier\n          } = _ref4;\n          return !installedIdentifiers.has(identifier);\n        }).map(_ref5 => {\n          let {\n            name,\n            identifier,\n            icon,\n            url\n          } = _ref5;\n          return {\n            type: ConnectType.EXTENSION,\n            identifier,\n            name,\n            icon,\n            url\n          };\n        });\n      }));\n    };\n    /**\n     * @see Wallet#status\n     * @see Wallet#network\n     * @see Wallet#wallets\n     */\n\n\n    this.states = () => {\n      return this._states.asObservable();\n    };\n    /** get connectedWallet */\n\n\n    this.connectedWallet = () => {\n      return this._states.pipe(toConnectedWallet(this));\n    };\n    /** get lcdClient */\n\n\n    this.lcdClient = lcdClientConfig => {\n      return this._states.pipe(toLcdClient(lcdClientConfig));\n    };\n    /**\n     * reload the connected wallet states\n     *\n     * in this time, this only work on the ConnectType.EXTENSION\n     *\n     * @see Wallet#recheckStatus\n     */\n\n\n    this.refetchStates = () => {\n      var _a;\n\n      if (this.disableExtension) {\n        (_a = this.extension) === null || _a === void 0 ? void 0 : _a.refetchStates();\n      }\n    };\n    /**\n     * @deprecated Please use availableInstallations\n     *\n     * install for the connect type\n     *\n     * @see Wallet#install\n     */\n\n\n    this.install = type => {\n      if (type === ConnectType.EXTENSION) {\n        // TODO separate install links by browser types\n        window.open(CHROME_EXTENSION_INSTALL_URL, '_blank');\n      } else {\n        console.warn(`[WalletController] ConnectType \"${type}\" does not support install() function`);\n      }\n    };\n    /**\n     * connect to wallet\n     *\n     * @see Wallet#connect\n     */\n\n\n    this.connect = async (_type, _identifier) => {\n      var _a, _b, _c, _d;\n\n      let type;\n      let identifier;\n\n      if (!!_type) {\n        type = _type;\n        identifier = _identifier;\n      } else {\n        const connections = await firstValueFrom(this.availableConnections());\n        const selector = (_a = this.options.selectConnection) !== null && _a !== void 0 ? _a : selectConnection;\n        const selected = await selector(connections);\n\n        if (!selected) {\n          return;\n        }\n\n        type = selected[0];\n        identifier = selected[1];\n      }\n\n      switch (type) {\n        case ConnectType.READONLY:\n          const networks = Object.keys(this.options.walletConnectChainIds).map(chainId => this.options.walletConnectChainIds[+chainId]);\n          const createReadonlyWalletSession = (_d = (_c = (_b = this.options).createReadonlyWalletSession) === null || _c === void 0 ? void 0 : _c.call(_b, networks)) !== null && _d !== void 0 ? _d : readonlyWalletModal({\n            networks\n          });\n          const readonlyWalletSession = await createReadonlyWalletSession;\n\n          if (readonlyWalletSession) {\n            this.enableReadonlyWallet(reConnect(readonlyWalletSession));\n          }\n\n          break;\n\n        case ConnectType.WALLETCONNECT:\n          this.enableWalletConnect(wcConnect(this.options));\n          break;\n\n        case ConnectType.EXTENSION:\n          if (!this.extension) {\n            throw new Error(`extension instance is not created!`);\n          }\n\n          this.extension.connect(identifier);\n          this.enableExtension();\n          break;\n\n        default:\n          throw new Error(`Unknown ConnectType!`);\n      }\n    };\n    /**\n     * manual connect to read only session\n     *\n     * @see Wallet#connectReadonly\n     */\n\n\n    this.connectReadonly = (terraAddress, network) => {\n      this.enableReadonlyWallet(reConnect({\n        terraAddress,\n        network\n      }));\n    };\n    /** @see Wallet#disconnect */\n\n\n    this.disconnect = () => {\n      var _a, _b, _c;\n\n      (_a = this.disableReadonlyWallet) === null || _a === void 0 ? void 0 : _a.call(this);\n      this.disableReadonlyWallet = null;\n      (_b = this.disableExtension) === null || _b === void 0 ? void 0 : _b.call(this);\n      this.disableExtension = null;\n      (_c = this.disableWalletConnect) === null || _c === void 0 ? void 0 : _c.call(this);\n      this.disableWalletConnect = null;\n      this.updateStates(this._notConnected);\n    };\n    /**\n     * @see Wallet#post\n     * @param tx\n     * @param terraAddress only available new extension\n     */\n\n\n    this.post = async (tx, terraAddress) => {\n      // ---------------------------------------------\n      // extension\n      // ---------------------------------------------\n      if (this.disableExtension) {\n        return new Promise((resolve, reject) => {\n          if (!this.extension) {\n            reject(new Error(`extension instance not created!`));\n            return;\n          }\n\n          const subscription = this.extension.post(tx, terraAddress).subscribe({\n            next: txResult => {\n              if (txResult.status === WebExtensionTxStatus.SUCCEED) {\n                resolve({ ...tx,\n                  result: txResult.payload,\n                  success: true\n                });\n                subscription.unsubscribe();\n              }\n            },\n            error: error => {\n              reject(mapExtensionTxError(tx, error));\n              subscription.unsubscribe();\n            }\n          });\n        });\n      } // ---------------------------------------------\n      // wallet connect\n      // ---------------------------------------------\n      else if (this.walletConnect) {\n        return this.walletConnect.post(tx).then(result => ({ ...tx,\n          result,\n          success: true\n        })).catch(error => {\n          throw mapWalletConnectError(tx, error);\n        });\n      } else {\n        throw new Error(`There are no connections that can be posting tx!`);\n      }\n    };\n    /**\n     * @see Wallet#sign\n     * @param tx\n     * @param terraAddress only available new extension\n     */\n\n\n    this.sign = async (tx, terraAddress) => {\n      if (this.disableExtension) {\n        return new Promise((resolve, reject) => {\n          if (!this.extension) {\n            reject(new Error(`extension instance is not created!`));\n            return;\n          }\n\n          const subscription = this.extension.sign(tx, terraAddress).subscribe({\n            next: txResult => {\n              if (txResult.status === WebExtensionTxStatus.SUCCEED) {\n                resolve({ ...tx,\n                  result: Tx.fromData(txResult.payload),\n                  success: true\n                });\n                subscription.unsubscribe();\n              }\n            },\n            error: error => {\n              reject(mapExtensionTxError(tx, error));\n              subscription.unsubscribe();\n            }\n          });\n        });\n      }\n\n      throw new Error(`sign() method only available on extension`);\n    };\n    /**\n     * @see Wallet#signBytes\n     * @param bytes\n     * @param terraAddress only available new extension\n     */\n\n\n    this.signBytes = async (bytes, terraAddress) => {\n      if (this.disableExtension) {\n        return new Promise((resolve, reject) => {\n          if (!this.extension) {\n            reject(new Error(`extension instance is not created!`));\n            return;\n          }\n\n          const subscription = this.extension.signBytes(bytes, terraAddress).subscribe({\n            next: txResult => {\n              if (txResult.status === WebExtensionTxStatus.SUCCEED) {\n                resolve({\n                  result: {\n                    recid: txResult.payload.recid,\n                    signature: Uint8Array.from(Buffer.from(txResult.payload.signature, 'base64')),\n                    public_key: txResult.payload.public_key ? PublicKey.fromData(txResult.payload.public_key) : undefined\n                  },\n                  success: true\n                });\n                subscription.unsubscribe();\n              }\n            },\n            error: error => {\n              reject(mapExtensionSignBytesError(bytes, error));\n              subscription.unsubscribe();\n            }\n          });\n        });\n      }\n\n      throw new Error(`signBytes() method only available on extension`); // TODO implements signBytes() to other connect types\n    };\n    /**\n     * @see Wallet#hasCW20Tokens\n     * @param chainID\n     * @param tokenAddrs Token addresses\n     */\n\n\n    this.hasCW20Tokens = async function (chainID) {\n      if (_this.availableExtensionFeature('cw20-token')) {\n        for (var _len = arguments.length, tokenAddrs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          tokenAddrs[_key - 1] = arguments[_key];\n        }\n\n        return _this.extension.hasCW20Tokens(chainID, ...tokenAddrs);\n      }\n\n      throw new Error(`Does not support hasCW20Tokens() on this connection`);\n    };\n    /**\n     * @see Wallet#addCW20Tokens\n     * @param chainID\n     * @param tokenAddrs Token addresses\n     */\n\n\n    this.addCW20Tokens = async function (chainID) {\n      if (_this.availableExtensionFeature('cw20-token')) {\n        for (var _len2 = arguments.length, tokenAddrs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          tokenAddrs[_key2 - 1] = arguments[_key2];\n        }\n\n        return _this.extension.addCW20Tokens(chainID, ...tokenAddrs);\n      }\n\n      throw new Error(`Does not support addCW20Tokens() on this connection`);\n    };\n    /**\n     * @see Wallet#hasNetwork\n     * @param network\n     */\n\n\n    this.hasNetwork = network => {\n      if (this.availableExtensionFeature('network')) {\n        return this.extension.hasNetwork(network);\n      }\n\n      throw new Error(`Does not support hasNetwork() on this connection`);\n    };\n    /**\n     * @see Wallet#hasNetwork\n     * @param network\n     */\n\n\n    this.addNetwork = network => {\n      if (this.availableExtensionFeature('network')) {\n        return this.extension.addNetwork(network);\n      }\n\n      throw new Error(`Does not support addNetwork() on this connection`);\n    }; // ================================================================\n    // internal\n    // connect type changing\n    // ================================================================\n\n\n    this.availableExtensionFeature = feature => {\n      if (this.disableExtension && this.extension) {\n        const states = this.extension.getLastStates();\n        return states.type === ExtensionRouterStatus.WALLET_CONNECTED && states.supportFeatures.has(feature);\n      }\n    };\n\n    this.updateStates = next => {\n      const prev = this._states.getValue();\n\n      if (next.status === WalletStatus.WALLET_CONNECTED && next.wallets.length === 0) {\n        next = {\n          status: WalletStatus.WALLET_NOT_CONNECTED,\n          network: next.network\n        };\n      }\n\n      if (prev.status !== next.status || !deepEqual(prev, next)) {\n        this._states.next(next);\n      }\n    };\n\n    this.enableReadonlyWallet = readonlyWallet => {\n      var _a, _b, _c;\n\n      (_a = this.disableWalletConnect) === null || _a === void 0 ? void 0 : _a.call(this);\n      (_b = this.disableExtension) === null || _b === void 0 ? void 0 : _b.call(this);\n\n      if (this.readonlyWallet === readonlyWallet || ((_c = this.readonlyWallet) === null || _c === void 0 ? void 0 : _c.terraAddress) === readonlyWallet.terraAddress && this.readonlyWallet.network === readonlyWallet.network) {\n        return;\n      }\n\n      if (this.readonlyWallet) {\n        this.readonlyWallet.disconnect();\n      }\n\n      this.readonlyWallet = readonlyWallet;\n      this.updateStates({\n        status: WalletStatus.WALLET_CONNECTED,\n        network: readonlyWallet.network,\n        wallets: [{\n          connectType: ConnectType.READONLY,\n          terraAddress: readonlyWallet.terraAddress,\n          design: 'readonly'\n        }],\n        supportFeatures: EMPTY_SUPPORT_FEATURES,\n        connection: CONNECTIONS.READONLY\n      });\n\n      this.disableReadonlyWallet = () => {\n        readonlyWallet.disconnect();\n        this.readonlyWallet = null;\n        this.disableReadonlyWallet = null;\n      };\n    };\n\n    this.enableExtension = () => {\n      var _a, _b;\n\n      (_a = this.disableReadonlyWallet) === null || _a === void 0 ? void 0 : _a.call(this);\n      (_b = this.disableWalletConnect) === null || _b === void 0 ? void 0 : _b.call(this);\n\n      if (this.disableExtension || !this.extension) {\n        return;\n      }\n\n      const extensionSubscription = this.extension.states().subscribe({\n        next: extensionStates => {\n          if (extensionStates.type === ExtensionRouterStatus.WALLET_CONNECTED && AccAddress.validate(extensionStates.wallet.terraAddress)) {\n            this.updateStates({\n              status: WalletStatus.WALLET_CONNECTED,\n              network: extensionStates.network,\n              wallets: [{\n                connectType: ConnectType.EXTENSION,\n                terraAddress: extensionStates.wallet.terraAddress,\n                design: extensionStates.wallet.design\n              }],\n              supportFeatures: extensionStates.supportFeatures,\n              connection: memoConnection(ConnectType.EXTENSION, extensionStates.extensionInfo.name, extensionStates.extensionInfo.icon, extensionStates.extensionInfo.identifier)\n            });\n          } else {\n            this.updateStates(this._notConnected);\n          }\n        }\n      });\n\n      this.disableExtension = () => {\n        var _a;\n\n        (_a = this.extension) === null || _a === void 0 ? void 0 : _a.disconnect();\n        extensionSubscription.unsubscribe();\n        this.disableExtension = null;\n      };\n    };\n\n    this.enableWalletConnect = walletConnect => {\n      var _a, _b;\n\n      (_a = this.disableReadonlyWallet) === null || _a === void 0 ? void 0 : _a.call(this);\n      (_b = this.disableExtension) === null || _b === void 0 ? void 0 : _b.call(this);\n\n      if (this.walletConnect === walletConnect) {\n        return;\n      }\n\n      if (this.walletConnect) {\n        this.walletConnect.disconnect();\n      }\n\n      this.walletConnect = walletConnect;\n\n      const subscribeWalletConnect = wc => {\n        return wc.session().subscribe({\n          next: status => {\n            var _a;\n\n            switch (status.status) {\n              case WalletConnectSessionStatus.CONNECTED:\n                this.updateStates({\n                  status: WalletStatus.WALLET_CONNECTED,\n                  network: (_a = this.options.walletConnectChainIds[status.chainId]) !== null && _a !== void 0 ? _a : this.options.defaultNetwork,\n                  wallets: [{\n                    connectType: ConnectType.WALLETCONNECT,\n                    terraAddress: status.terraAddress,\n                    design: 'walletconnect'\n                  }],\n                  supportFeatures: WALLETCONNECT_SUPPORT_FEATURES,\n                  connection: CONNECTIONS.WALLETCONNECT\n                });\n                break;\n\n              default:\n                this.updateStates(this._notConnected);\n                break;\n            }\n          }\n        });\n      };\n\n      const walletConnectSessionSubscription = subscribeWalletConnect(walletConnect);\n\n      this.disableWalletConnect = () => {\n        var _a;\n\n        (_a = this.walletConnect) === null || _a === void 0 ? void 0 : _a.disconnect();\n        this.walletConnect = null;\n        walletConnectSessionSubscription.unsubscribe();\n        this.disableWalletConnect = null;\n      };\n    };\n\n    this._notConnected = {\n      status: WalletStatus.WALLET_NOT_CONNECTED,\n      network: options.defaultNetwork\n    };\n    this._initializing = {\n      status: WalletStatus.INITIALIZING,\n      network: options.defaultNetwork\n    };\n    this._availableConnectTypes = new BehaviorSubject([ConnectType.READONLY, ConnectType.WALLETCONNECT]);\n    this._availableInstallTypes = new BehaviorSubject([]);\n    this._states = new BehaviorSubject(this._initializing);\n    let numSessionCheck = 0; // wait checking the availability of the chrome extension\n    // 0. check if extension wallet session is exists\n\n    checkExtensionReady((_a = options.waitingChromeExtensionInstallCheck) !== null && _a !== void 0 ? _a : DEFAULT_WAITING_CHROME_EXTENSION_INSTALL_CHECK, this.isChromeExtensionCompatibleBrowser()).then(ready => {\n      var _a;\n\n      if (ready) {\n        this._availableConnectTypes.next([ConnectType.EXTENSION, ConnectType.WALLETCONNECT, ConnectType.READONLY]);\n\n        this.extension = new ExtensionRouter({\n          hostWindow: window,\n          selectExtension: options.selectExtension,\n          dangerously__chromeExtensionCompatibleBrowserCheck: (_a = options.dangerously__chromeExtensionCompatibleBrowserCheck) !== null && _a !== void 0 ? _a : DEFAULT_CHROME_EXTENSION_COMPATIBLE_BROWSER_CHECK,\n          defaultNetwork: options.defaultNetwork\n        });\n        const subscription = this.extension.states().pipe(filter(_ref6 => {\n          let {\n            type\n          } = _ref6;\n          return type !== ExtensionRouterStatus.INITIALIZING;\n        })).subscribe(extensionStates => {\n          try {\n            subscription.unsubscribe();\n          } catch (_a) {}\n\n          if (extensionStates.type === ExtensionRouterStatus.WALLET_CONNECTED && !this.disableWalletConnect && !this.disableReadonlyWallet) {\n            this.enableExtension();\n          } else if (numSessionCheck === 0) {\n            numSessionCheck += 1;\n          } else {\n            this.updateStates(this._notConnected);\n          }\n        });\n      } else {\n        if (isDesktopChrome(this.isChromeExtensionCompatibleBrowser())) {\n          this._availableInstallTypes.next([ConnectType.EXTENSION]);\n        }\n\n        if (numSessionCheck === 0) {\n          numSessionCheck += 1;\n        } else {\n          this.updateStates(this._notConnected);\n        }\n      }\n    }); // 1. check if readonly wallet session is exists\n\n    const draftReadonlyWallet = reConnectIfSessionExists();\n\n    if (draftReadonlyWallet) {\n      this.enableReadonlyWallet(draftReadonlyWallet);\n      return;\n    } // 2. check if walletconnect sesison is exists\n\n\n    const draftWalletConnect = wcConnectIfSessionExists(options);\n\n    if (draftWalletConnect && draftWalletConnect.getLatestSession().status === WalletConnectSessionStatus.CONNECTED) {\n      this.enableWalletConnect(draftWalletConnect);\n    } else if (numSessionCheck === 0) {\n      numSessionCheck += 1;\n    } else {\n      this.updateStates(this._notConnected);\n    }\n  }\n\n}\nconst memoizedConnections = new Map();\n\nfunction memoConnection(connectType, name, icon) {\n  let identifier = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n  const key = [connectType, name, icon, identifier].join(';');\n\n  if (memoizedConnections.has(key)) {\n    return memoizedConnections.get(key);\n  }\n\n  const connection = {\n    type: connectType,\n    name,\n    icon,\n    identifier\n  };\n  memoizedConnections.set(key, connection);\n  return connection;\n}","map":{"version":3,"sources":["../../../src/@terra-money/wallet-controller/controller.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  AccAddress,\n  CreateTxOptions,\n  LCDClient,\n  PublicKey,\n  Tx,\n} from '@terra-money/terra.js';\nimport {\n  ConnectedWallet,\n  Connection,\n  ConnectType,\n  Installation,\n  NetworkInfo,\n  SignBytesResult,\n  SignResult,\n  TxResult,\n  WalletLCDClientConfig,\n  WalletStates,\n  WalletStatus,\n} from '@terra-money/wallet-types';\nimport {\n  TerraWebExtensionFeatures,\n  WebExtensionTxStatus,\n} from '@terra-money/web-extension-interface';\nimport deepEqual from 'fast-deep-equal';\nimport {\n  BehaviorSubject,\n  combineLatest,\n  firstValueFrom,\n  Observable,\n  Subscription,\n} from 'rxjs';\nimport { filter, map } from 'rxjs/operators';\nimport {\n  CHROME_EXTENSION_INSTALL_URL,\n  DEFAULT_CHROME_EXTENSION_COMPATIBLE_BROWSER_CHECK,\n} from './env';\nimport {\n  mapExtensionSignBytesError,\n  mapExtensionTxError,\n} from './exception/mapExtensionTxError';\nimport { mapWalletConnectError } from './exception/mapWalletConnectError';\nimport { selectConnection } from './modules/connect-modal';\nimport {\n  ExtensionRouter,\n  ExtensionRouterStatus,\n} from './modules/extension-router';\nimport {\n  ExtensionInfo,\n  getTerraExtensions,\n} from './modules/extension-router/multiChannel';\nimport {\n  connect as reConnect,\n  connectIfSessionExists as reConnectIfSessionExists,\n  ReadonlyWalletController,\n  readonlyWalletModal,\n  ReadonlyWalletSession,\n} from './modules/readonly-wallet';\nimport {\n  connect as wcConnect,\n  connectIfSessionExists as wcConnectIfSessionExists,\n  WalletConnectController,\n  WalletConnectControllerOptions,\n  WalletConnectSessionStatus,\n} from './modules/walletconnect';\nimport { getExtensions } from './operators/getExtensions';\nimport { toConnectedWallet } from './operators/toConnectedWallet';\nimport { toLcdClient } from './operators/toLcdClient';\nimport { isDesktopChrome } from './utils/browser-check';\nimport { checkExtensionReady } from './utils/checkExtensionReady';\nimport { sortConnections } from './utils/sortConnections';\n\nexport interface WalletControllerOptions\n  extends WalletConnectControllerOptions {\n  /**\n   * ⚠️ Don't hardcoding this, use getChain Options()\n   *\n   * fallback network if controller is not connected\n   */\n  defaultNetwork: NetworkInfo;\n\n  /**\n   * ⚠️ Don't hardcoding this, use getChain Options()\n   *\n   * for walletconnect\n   *\n   * The network rules passed by the Terra Station Mobile are 0 is testnet, 1 is mainnet.\n   *\n   * Always set testnet for 0 and mainnet for 1.\n   *\n   * @example\n   * ```\n   * const mainnet: NetworkInfo = {\n   *  name: 'mainnet',\n   *  chainID: 'columbus-5',\n   *  lcd: 'https://lcd.terra.dev',\n   * }\n   *\n   * const testnet: NetworkInfo = {\n   *  name: 'testnet',\n   *  chainID: 'bombay-12',\n   *  lcd: 'https://bombay-lcd.terra.dev',\n   * }\n   *\n   * const walletConnectChainIds: Record<number, NetworkInfo> = {\n   *   0: testnet,\n   *   1: mainnet,\n   * }\n   *\n   * <WalletProvider walletConnectChainIds={walletConnectChainIds}>\n   * ```\n   */\n  walletConnectChainIds: Record<number, NetworkInfo>;\n\n  /**\n   * run at executing the `connect(ConnectType.READONLY)`\n   */\n  createReadonlyWalletSession?: (\n    networks: NetworkInfo[],\n  ) => Promise<ReadonlyWalletSession | null>;\n\n  /**\n   * run at executing the `connect()` - only used when does not input ConnectType\n   */\n  selectConnection?: (\n    connections: Connection[],\n  ) => Promise<[type: ConnectType, identifier: string | undefined] | null>;\n\n  /**\n   * run at executing the `connect(ConnectType.EXTENSION)`\n   * if user installed multiple wallets\n   */\n  selectExtension?: (\n    extensionInfos: ExtensionInfo[],\n  ) => Promise<ExtensionInfo | null>;\n\n  /**\n   * milliseconds to wait checking chrome extension is installed\n   *\n   * @default 1000 * 3 miliseconds\n   */\n  waitingChromeExtensionInstallCheck?: number;\n\n  /**\n   * ⚠️ This API is an option for wallet developers. Please don't use dApp developers.\n   *\n   * @example\n   * ```\n   * <WalletProvider dangerously__chromeExtensionCompatibleBrowserCheck={(userAgent: string) => {\n   *   return /MyWallet\\//.test(userAgent);\n   * }}>\n   * ```\n   */\n  dangerously__chromeExtensionCompatibleBrowserCheck?: (\n    userAgent: string,\n  ) => boolean;\n}\n\nconst CONNECTIONS = {\n  [ConnectType.READONLY]: {\n    type: ConnectType.READONLY,\n    name: 'View an address',\n    icon: 'https://assets.terra.money/icon/wallet-provider/readonly.svg',\n  } as Connection,\n  [ConnectType.WALLETCONNECT]: {\n    type: ConnectType.WALLETCONNECT,\n    name: 'Wallet Connect',\n    icon: 'https://assets.terra.money/icon/wallet-provider/walletconnect.svg',\n  } as Connection,\n} as const;\n\nconst DEFAULT_WAITING_CHROME_EXTENSION_INSTALL_CHECK = 1000 * 3;\n\nconst WALLETCONNECT_SUPPORT_FEATURES = new Set<TerraWebExtensionFeatures>([\n  'post',\n]);\n\nconst EMPTY_SUPPORT_FEATURES = new Set<TerraWebExtensionFeatures>();\n\n//noinspection ES6MissingAwait\nexport class WalletController {\n  private extension: ExtensionRouter | null = null;\n  private walletConnect: WalletConnectController | null = null;\n  private readonlyWallet: ReadonlyWalletController | null = null;\n\n  private _availableConnectTypes: BehaviorSubject<ConnectType[]>;\n  private _availableInstallTypes: BehaviorSubject<ConnectType[]>;\n  private _states: BehaviorSubject<WalletStates>;\n\n  private disableReadonlyWallet: (() => void) | null = null;\n  private disableExtension: (() => void) | null = null;\n  private disableWalletConnect: (() => void) | null = null;\n\n  private readonly _notConnected: WalletStates;\n  private readonly _initializing: WalletStates;\n\n  constructor(readonly options: WalletControllerOptions) {\n    this._notConnected = {\n      status: WalletStatus.WALLET_NOT_CONNECTED,\n      network: options.defaultNetwork,\n    };\n\n    this._initializing = {\n      status: WalletStatus.INITIALIZING,\n      network: options.defaultNetwork,\n    };\n\n    this._availableConnectTypes = new BehaviorSubject<ConnectType[]>([\n      ConnectType.READONLY,\n      ConnectType.WALLETCONNECT,\n    ]);\n\n    this._availableInstallTypes = new BehaviorSubject<ConnectType[]>([]);\n\n    this._states = new BehaviorSubject<WalletStates>(this._initializing);\n\n    let numSessionCheck: number = 0;\n\n    // wait checking the availability of the chrome extension\n    // 0. check if extension wallet session is exists\n    checkExtensionReady(\n      options.waitingChromeExtensionInstallCheck ??\n        DEFAULT_WAITING_CHROME_EXTENSION_INSTALL_CHECK,\n      this.isChromeExtensionCompatibleBrowser(),\n    ).then((ready: boolean) => {\n      if (ready) {\n        this._availableConnectTypes.next([\n          ConnectType.EXTENSION,\n          ConnectType.WALLETCONNECT,\n          ConnectType.READONLY,\n        ]);\n\n        this.extension = new ExtensionRouter({\n          hostWindow: window,\n          selectExtension: options.selectExtension,\n          dangerously__chromeExtensionCompatibleBrowserCheck:\n            options.dangerously__chromeExtensionCompatibleBrowserCheck ??\n            DEFAULT_CHROME_EXTENSION_COMPATIBLE_BROWSER_CHECK,\n          defaultNetwork: options.defaultNetwork,\n        });\n\n        const subscription = this.extension\n          .states()\n          .pipe(\n            filter(({ type }) => type !== ExtensionRouterStatus.INITIALIZING),\n          )\n          .subscribe((extensionStates) => {\n            try {\n              subscription.unsubscribe();\n            } catch {}\n\n            if (\n              extensionStates.type === ExtensionRouterStatus.WALLET_CONNECTED &&\n              !this.disableWalletConnect &&\n              !this.disableReadonlyWallet\n            ) {\n              this.enableExtension();\n            } else if (numSessionCheck === 0) {\n              numSessionCheck += 1;\n            } else {\n              this.updateStates(this._notConnected);\n            }\n          });\n      } else {\n        if (isDesktopChrome(this.isChromeExtensionCompatibleBrowser())) {\n          this._availableInstallTypes.next([ConnectType.EXTENSION]);\n        }\n\n        if (numSessionCheck === 0) {\n          numSessionCheck += 1;\n        } else {\n          this.updateStates(this._notConnected);\n        }\n      }\n    });\n\n    // 1. check if readonly wallet session is exists\n    const draftReadonlyWallet = reConnectIfSessionExists();\n\n    if (draftReadonlyWallet) {\n      this.enableReadonlyWallet(draftReadonlyWallet);\n      return;\n    }\n\n    // 2. check if walletconnect sesison is exists\n    const draftWalletConnect = wcConnectIfSessionExists(options);\n\n    if (\n      draftWalletConnect &&\n      draftWalletConnect.getLatestSession().status ===\n        WalletConnectSessionStatus.CONNECTED\n    ) {\n      this.enableWalletConnect(draftWalletConnect);\n    } else if (numSessionCheck === 0) {\n      numSessionCheck += 1;\n    } else {\n      this.updateStates(this._notConnected);\n    }\n  }\n\n  /**\n   * Some mobile wallet emulates the behavior of chrome extension.\n   * It confirms that the current connection environment is such a wallet.\n   * (If you are running connect() by checking availableConnectType, you do not need to use this API.)\n   *\n   * @see Wallet#isChromeExtensionCompatibleBrowser\n   */\n  isChromeExtensionCompatibleBrowser = (): boolean => {\n    return (\n      this.options.dangerously__chromeExtensionCompatibleBrowserCheck ??\n      DEFAULT_CHROME_EXTENSION_COMPATIBLE_BROWSER_CHECK\n    )(navigator.userAgent);\n  };\n\n  /**\n   * available connect types on the browser\n   *\n   * @see Wallet#availableConnectTypes\n   */\n  availableConnectTypes = (): Observable<ConnectType[]> => {\n    return this._availableConnectTypes.asObservable();\n  };\n\n  /**\n   * available connections includes identifier, name, icon\n   *\n   * @see Wallet#availableConnections\n   */\n  availableConnections = (): Observable<Connection[]> => {\n    return this._availableConnectTypes.pipe(\n      map((connectTypes) => {\n        const connections: Connection[] = [];\n\n        for (const connectType of connectTypes) {\n          if (connectType === ConnectType.EXTENSION) {\n            const terraExtensions = getTerraExtensions();\n\n            for (const terraExtension of terraExtensions) {\n              connections.push(\n                memoConnection(\n                  ConnectType.EXTENSION,\n                  terraExtension.name,\n                  terraExtension.icon,\n                  terraExtension.identifier,\n                ),\n              );\n            }\n          } else {\n            connections.push(CONNECTIONS[connectType]);\n          }\n        }\n\n        return sortConnections(connections);\n      }),\n    );\n  };\n\n  /**\n   * available install types on the browser\n   *\n   * in this time, this only contains [ConnectType.EXTENSION]\n   *\n   * @see Wallet#availableInstallTypes\n   */\n  availableInstallTypes = (): Observable<ConnectType[]> => {\n    return this._availableInstallTypes.asObservable();\n  };\n\n  /**\n   * available installations includes identifier, name, icon, url\n   *\n   * @see Wallet#availableInstallations\n   */\n  availableInstallations = (): Observable<Installation[]> => {\n    return combineLatest([this.availableConnections(), getExtensions()]).pipe(\n      map(([connections, extensions]) => {\n        const installedIdentifiers = new Set<string>(\n          connections\n            .filter(({ type, identifier }) => {\n              return type === ConnectType.EXTENSION && !!identifier;\n            })\n            .map(({ identifier }) => {\n              return identifier!;\n            }),\n        );\n\n        return extensions\n          .filter(({ identifier }) => {\n            return !installedIdentifiers.has(identifier);\n          })\n          .map(({ name, identifier, icon, url }) => {\n            return {\n              type: ConnectType.EXTENSION,\n              identifier,\n              name,\n              icon,\n              url,\n            };\n          });\n      }),\n    );\n  };\n\n  /**\n   * @see Wallet#status\n   * @see Wallet#network\n   * @see Wallet#wallets\n   */\n  states = (): Observable<WalletStates> => {\n    return this._states.asObservable();\n  };\n\n  /** get connectedWallet */\n  connectedWallet = (): Observable<ConnectedWallet | undefined> => {\n    return this._states.pipe(toConnectedWallet(this));\n  };\n\n  /** get lcdClient */\n  lcdClient = (\n    lcdClientConfig?: WalletLCDClientConfig,\n  ): Observable<LCDClient> => {\n    return this._states.pipe(toLcdClient(lcdClientConfig));\n  };\n\n  /**\n   * reload the connected wallet states\n   *\n   * in this time, this only work on the ConnectType.EXTENSION\n   *\n   * @see Wallet#recheckStatus\n   */\n  refetchStates = () => {\n    if (this.disableExtension) {\n      this.extension?.refetchStates();\n    }\n  };\n\n  /**\n   * @deprecated Please use availableInstallations\n   *\n   * install for the connect type\n   *\n   * @see Wallet#install\n   */\n  install = (type: ConnectType) => {\n    if (type === ConnectType.EXTENSION) {\n      // TODO separate install links by browser types\n      window.open(CHROME_EXTENSION_INSTALL_URL, '_blank');\n    } else {\n      console.warn(\n        `[WalletController] ConnectType \"${type}\" does not support install() function`,\n      );\n    }\n  };\n\n  /**\n   * connect to wallet\n   *\n   * @see Wallet#connect\n   */\n  connect = async (_type?: ConnectType, _identifier?: string) => {\n    let type: ConnectType;\n    let identifier: string | undefined;\n\n    if (!!_type) {\n      type = _type;\n      identifier = _identifier;\n    } else {\n      const connections = await firstValueFrom(this.availableConnections());\n      const selector = this.options.selectConnection ?? selectConnection;\n      const selected = await selector(connections);\n\n      if (!selected) {\n        return;\n      }\n\n      type = selected[0];\n      identifier = selected[1];\n    }\n\n    switch (type) {\n      case ConnectType.READONLY:\n        const networks: NetworkInfo[] = Object.keys(\n          this.options.walletConnectChainIds,\n        ).map((chainId) => this.options.walletConnectChainIds[+chainId]);\n\n        const createReadonlyWalletSession =\n          this.options.createReadonlyWalletSession?.(networks) ??\n          readonlyWalletModal({ networks });\n\n        const readonlyWalletSession = await createReadonlyWalletSession;\n\n        if (readonlyWalletSession) {\n          this.enableReadonlyWallet(reConnect(readonlyWalletSession));\n        }\n        break;\n      case ConnectType.WALLETCONNECT:\n        this.enableWalletConnect(wcConnect(this.options));\n        break;\n      case ConnectType.EXTENSION:\n        if (!this.extension) {\n          throw new Error(`extension instance is not created!`);\n        }\n        this.extension.connect(identifier);\n        this.enableExtension();\n        break;\n      default:\n        throw new Error(`Unknown ConnectType!`);\n    }\n  };\n\n  /**\n   * manual connect to read only session\n   *\n   * @see Wallet#connectReadonly\n   */\n  connectReadonly = (terraAddress: string, network: NetworkInfo) => {\n    this.enableReadonlyWallet(\n      reConnect({\n        terraAddress,\n        network,\n      }),\n    );\n  };\n\n  /** @see Wallet#disconnect */\n  disconnect = () => {\n    this.disableReadonlyWallet?.();\n    this.disableReadonlyWallet = null;\n\n    this.disableExtension?.();\n    this.disableExtension = null;\n\n    this.disableWalletConnect?.();\n    this.disableWalletConnect = null;\n\n    this.updateStates(this._notConnected);\n  };\n\n  /**\n   * @see Wallet#post\n   * @param tx\n   * @param terraAddress only available new extension\n   */\n  post = async (\n    tx: CreateTxOptions,\n    terraAddress?: string,\n  ): Promise<TxResult> => {\n    // ---------------------------------------------\n    // extension\n    // ---------------------------------------------\n    if (this.disableExtension) {\n      return new Promise<TxResult>((resolve, reject) => {\n        if (!this.extension) {\n          reject(new Error(`extension instance not created!`));\n          return;\n        }\n\n        const subscription = this.extension.post(tx, terraAddress).subscribe({\n          next: (txResult) => {\n            if (txResult.status === WebExtensionTxStatus.SUCCEED) {\n              resolve({\n                ...tx,\n                result: txResult.payload,\n                success: true,\n              });\n              subscription.unsubscribe();\n            }\n          },\n          error: (error) => {\n            reject(mapExtensionTxError(tx, error));\n            subscription.unsubscribe();\n          },\n        });\n      });\n    }\n    // ---------------------------------------------\n    // wallet connect\n    // ---------------------------------------------\n    else if (this.walletConnect) {\n      return this.walletConnect\n        .post(tx)\n        .then(\n          (result) =>\n            ({\n              ...tx,\n              result,\n              success: true,\n            } as TxResult),\n        )\n        .catch((error) => {\n          throw mapWalletConnectError(tx, error);\n        });\n    } else {\n      throw new Error(`There are no connections that can be posting tx!`);\n    }\n  };\n\n  /**\n   * @see Wallet#sign\n   * @param tx\n   * @param terraAddress only available new extension\n   */\n  sign = async (\n    tx: CreateTxOptions,\n    terraAddress?: string,\n  ): Promise<SignResult> => {\n    if (this.disableExtension) {\n      return new Promise<SignResult>((resolve, reject) => {\n        if (!this.extension) {\n          reject(new Error(`extension instance is not created!`));\n          return;\n        }\n\n        const subscription = this.extension.sign(tx, terraAddress).subscribe({\n          next: (txResult) => {\n            if (txResult.status === WebExtensionTxStatus.SUCCEED) {\n              resolve({\n                ...tx,\n                result: Tx.fromData(txResult.payload),\n                success: true,\n              });\n              subscription.unsubscribe();\n            }\n          },\n          error: (error) => {\n            reject(mapExtensionTxError(tx, error));\n            subscription.unsubscribe();\n          },\n        });\n      });\n    }\n\n    throw new Error(`sign() method only available on extension`);\n  };\n\n  /**\n   * @see Wallet#signBytes\n   * @param bytes\n   * @param terraAddress only available new extension\n   */\n  signBytes = async (\n    bytes: Buffer,\n    terraAddress?: string,\n  ): Promise<SignBytesResult> => {\n    if (this.disableExtension) {\n      return new Promise<SignBytesResult>((resolve, reject) => {\n        if (!this.extension) {\n          reject(new Error(`extension instance is not created!`));\n          return;\n        }\n\n        const subscription = this.extension\n          .signBytes(bytes, terraAddress)\n          .subscribe({\n            next: (txResult) => {\n              if (txResult.status === WebExtensionTxStatus.SUCCEED) {\n                resolve({\n                  result: {\n                    recid: txResult.payload.recid,\n                    signature: Uint8Array.from(\n                      Buffer.from(txResult.payload.signature, 'base64'),\n                    ),\n                    public_key: txResult.payload.public_key\n                      ? PublicKey.fromData(txResult.payload.public_key)\n                      : undefined,\n                  },\n                  success: true,\n                });\n                subscription.unsubscribe();\n              }\n            },\n            error: (error) => {\n              reject(mapExtensionSignBytesError(bytes, error));\n              subscription.unsubscribe();\n            },\n          });\n      });\n    }\n\n    throw new Error(`signBytes() method only available on extension`);\n    // TODO implements signBytes() to other connect types\n  };\n\n  /**\n   * @see Wallet#hasCW20Tokens\n   * @param chainID\n   * @param tokenAddrs Token addresses\n   */\n  hasCW20Tokens = async (\n    chainID: string,\n    ...tokenAddrs: string[]\n  ): Promise<{ [tokenAddr: string]: boolean }> => {\n    if (this.availableExtensionFeature('cw20-token')) {\n      return this.extension!.hasCW20Tokens(chainID, ...tokenAddrs);\n    }\n\n    throw new Error(`Does not support hasCW20Tokens() on this connection`);\n  };\n\n  /**\n   * @see Wallet#addCW20Tokens\n   * @param chainID\n   * @param tokenAddrs Token addresses\n   */\n  addCW20Tokens = async (\n    chainID: string,\n    ...tokenAddrs: string[]\n  ): Promise<{ [tokenAddr: string]: boolean }> => {\n    if (this.availableExtensionFeature('cw20-token')) {\n      return this.extension!.addCW20Tokens(chainID, ...tokenAddrs);\n    }\n\n    throw new Error(`Does not support addCW20Tokens() on this connection`);\n  };\n\n  /**\n   * @see Wallet#hasNetwork\n   * @param network\n   */\n  hasNetwork = (network: Omit<NetworkInfo, 'name'>): Promise<boolean> => {\n    if (this.availableExtensionFeature('network')) {\n      return this.extension!.hasNetwork(network);\n    }\n\n    throw new Error(`Does not support hasNetwork() on this connection`);\n  };\n\n  /**\n   * @see Wallet#hasNetwork\n   * @param network\n   */\n  addNetwork = (network: NetworkInfo): Promise<boolean> => {\n    if (this.availableExtensionFeature('network')) {\n      return this.extension!.addNetwork(network);\n    }\n\n    throw new Error(`Does not support addNetwork() on this connection`);\n  };\n\n  // ================================================================\n  // internal\n  // connect type changing\n  // ================================================================\n  private availableExtensionFeature = (feature: TerraWebExtensionFeatures) => {\n    if (this.disableExtension && this.extension) {\n      const states = this.extension.getLastStates();\n\n      return (\n        states.type === ExtensionRouterStatus.WALLET_CONNECTED &&\n        states.supportFeatures.has(feature)\n      );\n    }\n  };\n\n  private updateStates = (next: WalletStates) => {\n    const prev = this._states.getValue();\n\n    if (\n      next.status === WalletStatus.WALLET_CONNECTED &&\n      next.wallets.length === 0\n    ) {\n      next = {\n        status: WalletStatus.WALLET_NOT_CONNECTED,\n        network: next.network,\n      };\n    }\n\n    if (prev.status !== next.status || !deepEqual(prev, next)) {\n      this._states.next(next);\n    }\n  };\n\n  private enableReadonlyWallet = (readonlyWallet: ReadonlyWalletController) => {\n    this.disableWalletConnect?.();\n    this.disableExtension?.();\n\n    if (\n      this.readonlyWallet === readonlyWallet ||\n      (this.readonlyWallet?.terraAddress === readonlyWallet.terraAddress &&\n        this.readonlyWallet.network === readonlyWallet.network)\n    ) {\n      return;\n    }\n\n    if (this.readonlyWallet) {\n      this.readonlyWallet.disconnect();\n    }\n\n    this.readonlyWallet = readonlyWallet;\n\n    this.updateStates({\n      status: WalletStatus.WALLET_CONNECTED,\n      network: readonlyWallet.network,\n      wallets: [\n        {\n          connectType: ConnectType.READONLY,\n          terraAddress: readonlyWallet.terraAddress,\n          design: 'readonly',\n        },\n      ],\n      supportFeatures: EMPTY_SUPPORT_FEATURES,\n      connection: CONNECTIONS.READONLY,\n    });\n\n    this.disableReadonlyWallet = () => {\n      readonlyWallet.disconnect();\n      this.readonlyWallet = null;\n      this.disableReadonlyWallet = null;\n    };\n  };\n\n  private enableExtension = () => {\n    this.disableReadonlyWallet?.();\n    this.disableWalletConnect?.();\n\n    if (this.disableExtension || !this.extension) {\n      return;\n    }\n\n    const extensionSubscription = this.extension.states().subscribe({\n      next: (extensionStates) => {\n        if (\n          extensionStates.type === ExtensionRouterStatus.WALLET_CONNECTED &&\n          AccAddress.validate(extensionStates.wallet.terraAddress)\n        ) {\n          this.updateStates({\n            status: WalletStatus.WALLET_CONNECTED,\n            network: extensionStates.network,\n            wallets: [\n              {\n                connectType: ConnectType.EXTENSION,\n                terraAddress: extensionStates.wallet.terraAddress,\n                design: extensionStates.wallet.design,\n              },\n            ],\n            supportFeatures: extensionStates.supportFeatures,\n            connection: memoConnection(\n              ConnectType.EXTENSION,\n              extensionStates.extensionInfo.name,\n              extensionStates.extensionInfo.icon,\n              extensionStates.extensionInfo.identifier,\n            ),\n          });\n        } else {\n          this.updateStates(this._notConnected);\n        }\n      },\n    });\n\n    this.disableExtension = () => {\n      this.extension?.disconnect();\n      extensionSubscription.unsubscribe();\n      this.disableExtension = null;\n    };\n  };\n\n  private enableWalletConnect = (walletConnect: WalletConnectController) => {\n    this.disableReadonlyWallet?.();\n    this.disableExtension?.();\n\n    if (this.walletConnect === walletConnect) {\n      return;\n    }\n\n    if (this.walletConnect) {\n      this.walletConnect.disconnect();\n    }\n\n    this.walletConnect = walletConnect;\n\n    const subscribeWalletConnect = (\n      wc: WalletConnectController,\n    ): Subscription => {\n      return wc.session().subscribe({\n        next: (status) => {\n          switch (status.status) {\n            case WalletConnectSessionStatus.CONNECTED:\n              this.updateStates({\n                status: WalletStatus.WALLET_CONNECTED,\n                network:\n                  this.options.walletConnectChainIds[status.chainId] ??\n                  this.options.defaultNetwork,\n                wallets: [\n                  {\n                    connectType: ConnectType.WALLETCONNECT,\n                    terraAddress: status.terraAddress,\n                    design: 'walletconnect',\n                  },\n                ],\n                supportFeatures: WALLETCONNECT_SUPPORT_FEATURES,\n                connection: CONNECTIONS.WALLETCONNECT,\n              });\n              break;\n            default:\n              this.updateStates(this._notConnected);\n              break;\n          }\n        },\n      });\n    };\n\n    const walletConnectSessionSubscription =\n      subscribeWalletConnect(walletConnect);\n\n    this.disableWalletConnect = () => {\n      this.walletConnect?.disconnect();\n      this.walletConnect = null;\n      walletConnectSessionSubscription.unsubscribe();\n      this.disableWalletConnect = null;\n    };\n  };\n}\n\nconst memoizedConnections = new Map<string, Connection>();\n\nfunction memoConnection(\n  connectType: ConnectType,\n  name: string,\n  icon: string,\n  identifier: string | undefined = '',\n): Connection {\n  const key = [connectType, name, icon, identifier].join(';');\n\n  if (memoizedConnections.has(key)) {\n    return memoizedConnections.get(key)!;\n  }\n\n  const connection: Connection = {\n    type: connectType,\n    name,\n    icon,\n    identifier,\n  };\n\n  memoizedConnections.set(key, connection);\n\n  return connection;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}